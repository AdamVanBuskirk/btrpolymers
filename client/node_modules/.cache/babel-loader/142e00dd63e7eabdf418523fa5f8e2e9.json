{"ast":null,"code":"import { normalizeInterval } from \"./_lib/normalizeInterval.js\";\nimport { constructFrom } from \"./constructFrom.js\";\n/**\n * The {@link eachMonthOfInterval} function options.\n */\n\n/**\n * The {@link eachMonthOfInterval} function result type. It resolves the proper data type.\n */\n\n/**\n * @name eachMonthOfInterval\n * @category Interval Helpers\n * @summary Return the array of months within the specified time interval.\n *\n * @description\n * Return the array of months within the specified time interval.\n *\n * @typeParam IntervalType - Interval type.\n * @typeParam Options - Options type.\n *\n * @param interval - The interval.\n * @param options - An object with options.\n *\n * @returns The array with starts of months from the month of the interval start to the month of the interval end\n *\n * @example\n * // Each month between 6 February 2014 and 10 August 2014:\n * const result = eachMonthOfInterval({\n *   start: new Date(2014, 1, 6),\n *   end: new Date(2014, 7, 10)\n * })\n * //=> [\n * //   Sat Feb 01 2014 00:00:00,\n * //   Sat Mar 01 2014 00:00:00,\n * //   Tue Apr 01 2014 00:00:00,\n * //   Thu May 01 2014 00:00:00,\n * //   Sun Jun 01 2014 00:00:00,\n * //   Tue Jul 01 2014 00:00:00,\n * //   Fri Aug 01 2014 00:00:00\n * // ]\n */\n\nexport function eachMonthOfInterval(interval, options) {\n  var _options$step;\n\n  var _normalizeInterval = normalizeInterval(options === null || options === void 0 ? void 0 : options.in, interval),\n      start = _normalizeInterval.start,\n      end = _normalizeInterval.end;\n\n  var reversed = +start > +end;\n  var endTime = reversed ? +start : +end;\n  var date = reversed ? end : start;\n  date.setHours(0, 0, 0, 0);\n  date.setDate(1);\n  var step = (_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1;\n  if (!step) return [];\n\n  if (step < 0) {\n    step = -step;\n    reversed = !reversed;\n  }\n\n  var dates = [];\n\n  while (+date <= endTime) {\n    dates.push(constructFrom(start, date));\n    date.setMonth(date.getMonth() + step);\n  }\n\n  return reversed ? dates.reverse() : dates;\n} // Fallback for modularized imports:\n\nexport default eachMonthOfInterval;","map":{"version":3,"names":["normalizeInterval","constructFrom","eachMonthOfInterval","interval","options","in","start","end","reversed","endTime","date","setHours","setDate","step","dates","push","setMonth","getMonth","reverse"],"sources":["/Users/adamvanbuskirk/Sites/btrpolymers/client/node_modules/date-fns/eachMonthOfInterval.js"],"sourcesContent":["import { normalizeInterval } from \"./_lib/normalizeInterval.js\";\nimport { constructFrom } from \"./constructFrom.js\";\n\n/**\n * The {@link eachMonthOfInterval} function options.\n */\n\n/**\n * The {@link eachMonthOfInterval} function result type. It resolves the proper data type.\n */\n\n/**\n * @name eachMonthOfInterval\n * @category Interval Helpers\n * @summary Return the array of months within the specified time interval.\n *\n * @description\n * Return the array of months within the specified time interval.\n *\n * @typeParam IntervalType - Interval type.\n * @typeParam Options - Options type.\n *\n * @param interval - The interval.\n * @param options - An object with options.\n *\n * @returns The array with starts of months from the month of the interval start to the month of the interval end\n *\n * @example\n * // Each month between 6 February 2014 and 10 August 2014:\n * const result = eachMonthOfInterval({\n *   start: new Date(2014, 1, 6),\n *   end: new Date(2014, 7, 10)\n * })\n * //=> [\n * //   Sat Feb 01 2014 00:00:00,\n * //   Sat Mar 01 2014 00:00:00,\n * //   Tue Apr 01 2014 00:00:00,\n * //   Thu May 01 2014 00:00:00,\n * //   Sun Jun 01 2014 00:00:00,\n * //   Tue Jul 01 2014 00:00:00,\n * //   Fri Aug 01 2014 00:00:00\n * // ]\n */\nexport function eachMonthOfInterval(interval, options) {\n  const { start, end } = normalizeInterval(options?.in, interval);\n\n  let reversed = +start > +end;\n  const endTime = reversed ? +start : +end;\n  const date = reversed ? end : start;\n  date.setHours(0, 0, 0, 0);\n  date.setDate(1);\n\n  let step = options?.step ?? 1;\n  if (!step) return [];\n  if (step < 0) {\n    step = -step;\n    reversed = !reversed;\n  }\n\n  const dates = [];\n\n  while (+date <= endTime) {\n    dates.push(constructFrom(start, date));\n    date.setMonth(date.getMonth() + step);\n  }\n\n  return reversed ? dates.reverse() : dates;\n}\n\n// Fallback for modularized imports:\nexport default eachMonthOfInterval;\n"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,6BAAlC;AACA,SAASC,aAAT,QAA8B,oBAA9B;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,mBAAT,CAA6BC,QAA7B,EAAuCC,OAAvC,EAAgD;EAAA;;EACrD,yBAAuBJ,iBAAiB,CAACI,OAAD,aAACA,OAAD,uBAACA,OAAO,CAAEC,EAAV,EAAcF,QAAd,CAAxC;EAAA,IAAQG,KAAR,sBAAQA,KAAR;EAAA,IAAeC,GAAf,sBAAeA,GAAf;;EAEA,IAAIC,QAAQ,GAAG,CAACF,KAAD,GAAS,CAACC,GAAzB;EACA,IAAME,OAAO,GAAGD,QAAQ,GAAG,CAACF,KAAJ,GAAY,CAACC,GAArC;EACA,IAAMG,IAAI,GAAGF,QAAQ,GAAGD,GAAH,GAASD,KAA9B;EACAI,IAAI,CAACC,QAAL,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;EACAD,IAAI,CAACE,OAAL,CAAa,CAAb;EAEA,IAAIC,IAAI,oBAAGT,OAAH,aAAGA,OAAH,uBAAGA,OAAO,CAAES,IAAZ,yDAAoB,CAA5B;EACA,IAAI,CAACA,IAAL,EAAW,OAAO,EAAP;;EACX,IAAIA,IAAI,GAAG,CAAX,EAAc;IACZA,IAAI,GAAG,CAACA,IAAR;IACAL,QAAQ,GAAG,CAACA,QAAZ;EACD;;EAED,IAAMM,KAAK,GAAG,EAAd;;EAEA,OAAO,CAACJ,IAAD,IAASD,OAAhB,EAAyB;IACvBK,KAAK,CAACC,IAAN,CAAWd,aAAa,CAACK,KAAD,EAAQI,IAAR,CAAxB;IACAA,IAAI,CAACM,QAAL,CAAcN,IAAI,CAACO,QAAL,KAAkBJ,IAAhC;EACD;;EAED,OAAOL,QAAQ,GAAGM,KAAK,CAACI,OAAN,EAAH,GAAqBJ,KAApC;AACD,C,CAED;;AACA,eAAeZ,mBAAf"},"metadata":{},"sourceType":"module"}